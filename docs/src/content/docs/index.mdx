---
title: Effortless AWS
description: Code-first AWS Lambda framework. Export handlers, deploy with one command.
template: splash
---

import { Card, CardGrid, Tabs, TabItem } from '@astrojs/starlight/components';
import AnimatedHero from '../../components/AnimatedHero.astro';

<AnimatedHero />

## Features

<CardGrid>
  <Card title="Infrastructure from code">
    Export a handler — get Lambda, API Gateway, DynamoDB, IAM. No YAML, no config files. Inspired by [Firebase](https://firebase.google.com/). [Learn more →](/handlers/)
  </Card>
  <Card title="Deploy in seconds">
    Direct AWS SDK calls. No CloudFormation, no Pulumi. Deploy in ~5-10s, not 5-10 minutes. [Why not CloudFormation →](/faq/#why-not-cloudformation)
  </Card>
  <Card title="Typed everything">
    `defineTable<Order>` gives you typed `put()`, typed `deps.orders.get()`, typed `record.new`. One definition, types flow everywhere. [Handlers →](/handlers/)
  </Card>
  <Card title="No state files">
    AWS resource tags are the source of truth. No tfstate, no S3 backends, no drift. [How it works →](/architecture/#resource-discovery)
  </Card>
  <Card title="Built-in best practices">
    Partial batch failures, cold start caching, schema validation, typed event parsing. Serverless patterns baked in — inspired by [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/). [Details →](/getting-started/#built-in-best-practices)
  </Card>
  <Card title="Auto-wired permissions">
    Reference another handler with `deps: { orders }` — IAM permissions and typed clients are injected automatically. Secrets via `param("key")` — fetched from SSM at cold start. [Architecture →](/architecture/#inter-handler-dependencies-deps)
  </Card>
  <Card title="Smart Lambda Layers">
    Production deps from `node_modules` are auto-packaged into a shared Lambda Layer. Works with npm, pnpm, yarn. Hash-based versioning — re-uploads only when deps change. [Details →](/architecture/#lambda-layer-production-dependencies)
  </Card>
</CardGrid>

## Examples

<Tabs>
  <TabItem label="HTTP API">
    ```typescript
    // src/api.ts
    import { defineHttp } from "effortless-aws";

    export const hello = defineHttp({
      method: "GET",
      path: "/hello/{name}",
      onRequest: async ({ req }) => {
        return {
          status: 200,
          body: { message: `Hello, ${req.params.name}!` },
        };
      },
    });
    ```
    Creates: Lambda + API Gateway `GET /hello/{name}` route + IAM role.
  </TabItem>
  <TabItem label="DynamoDB + API">
    ```typescript
    // src/orders.ts
    import { defineTable, defineHttp } from "effortless-aws";

    type Order = { id: string; product: string; amount: number };

    export const orders = defineTable<Order>({
      pk: { name: "id", type: "string" },
      onRecord: async ({ record }) => {
        if (record.eventName === "INSERT") {
          console.log("New order:", record.new!.product);
        }
      },
    });

    export const createOrder = defineHttp({
      method: "POST",
      path: "/orders",
      deps: { orders },
      onRequest: async ({ req, deps }) => {
        await deps.orders.put({
          id: crypto.randomUUID(),
          product: req.body.product,
          amount: req.body.amount,
        });
        return { status: 201, body: { ok: true } };
      },
    });
    ```
    Creates: DynamoDB table with stream + stream processor Lambda + HTTP Lambda with DynamoDB write permissions + API Gateway route. All from one file.
  </TabItem>
  <TabItem label="Static site">
    ```typescript
    // src/site.ts
    import { defineSite } from "effortless-aws";

    export const docs = defineSite({
      path: "/",
      dir: "dist",
      build: "npx astro build",
    });
    ```
    Creates: Lambda that serves static files from `dist/` + API Gateway routes. Runs the build command before deploy. Automatic content-type detection, caching headers, binary file support.
  </TabItem>
</Tabs>

```bash
npx eff deploy
```

## How it works

1. **Static analysis** (ts-morph) — reads your exports, extracts handler config from AST
2. **Bundle** (esbuild) — wraps each handler with a runtime adapter, tree-shaken per function
3. **Deploy** (AWS SDK) — creates/updates Lambda, API Gateway, DynamoDB, IAM directly

No CloudFormation stacks. No Terraform state. Tags on AWS resources are the only state.

## Compared to

| | SST v3 | Nitric | Serverless | **Effortless** |
|---|---|---|---|---|
| Infra from code (not config) | No | Yes | No | **Yes** |
| Typed client from schema | No | No | No | **Yes** |
| No state files | No | No | No | **Yes** |
| Deploy speed | ~30s | ~30s | minutes | **~5-10s** |
| Runs in your AWS account | Yes | Yes | Yes | **Yes** |
| Open source | Yes | Yes | Yes | **Yes** |
